use std::mem;

fn gcd(mut left: u64, mut right: u64) -> u64 {
    while right != 0 {
        mem::swap(&mut left, &mut right);
        right %= left;
    }
    left
}

fn actual_quicksort<T, F: Fn(&T, &T) -> bool>(array: &mut [T], isLeftGreaterRight: &F) {
    let len = array.len();
    if len < 2 {
        return;
    }

    let last = len - 1;
    let random_pivot_position = len / 2;
    array.swap(random_pivot_position, last);

    let mut i = 0usize;
    let mut j = last - 1;
    {
        while i < j {
            if isLeftGreaterRight(&array[last], &array[i]) {
                i += 1;
                continue;
            }

            if isLeftGreaterRight(&array[j], &array[last]) {
                j -= 1;
                continue;
            }

            array.swap(i, j);
        }
    }
    array.swap(i, last);

    actual_quicksort(&mut array[0 .. i], isLeftGreaterRight);
    actual_quicksort(&mut array[i + 1 .. len], isLeftGreaterRight);
}

pub fn quicksort<T, F: Fn(&T, &T) -> bool>(array: &mut [T], isLeftGreaterRight: F) {
    actual_quicksort(array, &isLeftGreaterRight);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn odd_elements() {
        let mut v = vec![3,2,1];
        quicksort(&mut v, |x, y| x > y);
        assert_eq!(v, vec![1,2,3]);
    }

    #[test]
    fn even_elements() {
        let mut v = vec![4,3,2,1];
        quicksort(&mut v, |x, y| x > y);
        assert_eq!(v, vec![1,2,3,4]);
    }

    #[test]
    fn single_element() {
        let mut v = vec![4];
        quicksort(&mut v, |x, y| x > y);
        assert_eq!(v, vec![4]);
    }

    #[test]
    fn two_element() {
        let mut v = vec![4,2];
        quicksort(&mut v, |x, y| x > y);
        assert_eq!(v, vec![2, 4]);
    }

    #[test]
    fn equal_elements() {
        let mut v = vec![4,4,2,1];
        quicksort(&mut v, |x, y| x > y);
        assert_eq!(v, vec![1, 2 ,4, 4]);
    }

}
